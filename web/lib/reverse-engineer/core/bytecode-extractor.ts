// web/lib/reverse-engineer/core/bytecode-extractor.ts

export interface BytecodeInfo {
  raw: number[];
  decrypted?: number[];
  encrypted: boolean;
  encryptionType?: 'xor' | 'aes' | 'custom';
  key?: number[];
  location: string;
  size: number;
  entropy: number;
  patterns: BytecodePattern[];
}

export interface BytecodePattern {
  type: 'constant' | 'jump' | 'call' | 'return' | 'arithmetic';
  frequency: number;
  locations: number[];
}

export class BytecodeExtractor {
  private patterns: Map<string, RegExp> = new Map();

  constructor() {
    this.initializePatterns();
  }

  /**
   * Initialize bytecode patterns
   */
  private initializePatterns(): void {
    this.patterns.set('xor_encrypted', /bytecode\s*=\s*encrypt\(([^,]+),\s*(\d+)\)/);
    this.patterns.set('base64_encoded', /bytecode\s*=\s*base64\.decode\(([^)]+)\)/);
    this.patterns.set('chunked', /bytecode\s*=\s*chunks?\[\d+\]/);
    this.patterns.set('embedded', /bytecode\s*=\s*{([^}]+)}/);
    this.patterns.set('function_generated', /load\(function\(\)\s*return\s*{([^}]+)}/);
  }

  /**
   * Extract bytecode from code
   */
  extract(code: string): BytecodeInfo[] {
    const results: BytecodeInfo[] = [];
    
    // Try different extraction methods
    const direct = this.extractDirect(code);
    if (direct) results.push(direct);
    
    const encrypted = this.extractEncrypted(code);
    if (encrypted) results.push(encrypted);
    
    const chunked = this.extractChunked(code);
    if (chunked) results.push(...chunked);
    
    const generated = this.extractGenerated(code);
    if (generated) results.push(generated);
    
    return results;
  }

  /**
   * Extract direct bytecode table
   */
  private extractDirect(code: string): BytecodeInfo | null {
    const match = code.match(/bytecode\s*=\s*{([^}]+)}/);
    if (!match) return null;
    
    const bytes = this.parseBytecode(match[1]);
    
    return {
      raw: bytes,
      encrypted: false,
      location: match[0],
      size: bytes.length,
      entropy: this.calculateEntropy(bytes),
      patterns: this.analyzePatterns(bytes)
    };
  }

  /**
   * Extract encrypted bytecode
   */
  private extractEncrypted(code: string): BytecodeInfo | null {
    // XOR pattern
    const xorMatch = code.match(/bytecode\s*=\s*encrypt\(([^,]+),\s*(\d+)\)/);
    if (xorMatch) {
      const bytes = this.parseBytecode(xorMatch[1]);
      const key = parseInt(xorMatch[2]);
      
      return {
        raw: bytes,
        encrypted: true,
        encryptionType: 'xor',
        key: [key],
        location: xorMatch[0],
        size: bytes.length,
        entropy: this.calculateEntropy(bytes),
        patterns: this.analyzePatterns(bytes)
      };
    }
    
    // Base64 pattern
    const base64Match = code.match(/bytecode\s*=\s*base64\.decode\(['"]([^'"]+)['"]\)/);
    if (base64Match) {
      const decoded = Buffer.from(base64Match[1], 'base64');
      const bytes = Array.from(decoded);
      
      return {
        raw: bytes,
        encrypted: true,
        encryptionType: 'custom',
        location: base64Match[0],
        size: bytes.length,
        entropy: this.calculateEntropy(bytes),
        patterns: this.analyzePatterns(bytes)
      };
    }
    
    return null;
  }

  /**
   * Extract chunked bytecode
   */
  private extractChunked(code: string): BytecodeInfo[] {
    const results: BytecodeInfo[] = [];
    const chunkMatches = code.matchAll(/chunks?\[\d+\]\s*=\s*{([^}]+)}/g);
    
    for (const match of chunkMatches) {
      const bytes = this.parseBytecode(match[1]);
      results.push({
        raw: bytes,
        encrypted: false,
        location: match[0],
        size: bytes.length,
        entropy: this.calculateEntropy(bytes),
        patterns: this.analyzePatterns(bytes)
      });
    }
    
    return results;
  }

  /**
   * Extract generated bytecode
   */
  private extractGenerated(code: string): BytecodeInfo | null {
    const match = code.match(/load\(function\(\)\s*return\s*{([^}]+)}/);
    if (!match) return null;
    
    const bytes = this.parseBytecode(match[1]);
    
    return {
      raw: bytes,
      encrypted: false,
      location: match[0],
      size: bytes.length,
      entropy: this.calculateEntropy(bytes),
      patterns: this.analyzePatterns(bytes)
    };
  }

  /**
   * Parse bytecode string to numbers
   */
  private parseBytecode(str: string): number[] {
    return str.split(',')
      .map(s => s.trim())
      .map(s => {
        if (s.startsWith('0x')) return parseInt(s, 16);
        if (s.startsWith('0b')) return parseInt(s.slice(2), 2);
        return parseInt(s, 10);
      })
      .filter(n => !isNaN(n));
  }

  /**
   * Calculate entropy of bytecode
   */
  private calculateEntropy(bytes: number[]): number {
    const freq = new Map<number, number>();
    
    bytes.forEach(b => {
      freq.set(b, (freq.get(b) || 0) + 1);
    });
    
    let entropy = 0;
    freq.forEach(count => {
      const p = count / bytes.length;
      entropy -= p * Math.log2(p);
    });
    
    return entropy;
  }

  /**
   * Analyze bytecode patterns
   */
  private analyzePatterns(bytes: number[]): BytecodePattern[] {
    const patterns: BytecodePattern[] = [];
    
    // Look for constant patterns
    const constants = this.findConstants(bytes);
    if (constants.length > 0) {
      patterns.push({
        type: 'constant',
        frequency: constants.length,
        locations: constants
      });
    }
    
    // Look for jump patterns
    const jumps = this.findJumps(bytes);
    if (jumps.length > 0) {
      patterns.push({
        type: 'jump',
        frequency: jumps.length,
        locations: jumps
      });
    }
    
    // Look for call patterns
    const calls = this.findCalls(bytes);
    if (calls.length > 0) {
      patterns.push({
        type: 'call',
        frequency: calls.length,
        locations: calls
      });
    }
    
    return patterns;
  }

  /**
   * Find constant accesses
   */
  private findConstants(bytes: number[]): number[] {
    const locations: number[] = [];
    
    for (let i = 0; i < bytes.length - 2; i++) {
      // LOADK pattern (opcode followed by two operands)
      if (bytes[i] === 1) { // Assuming 1 is LOADK
        locations.push(i);
      }
    }
    
    return locations;
  }

  /**
   * Find jumps
   */
  private findJumps(bytes: number[]): number[] {
    const locations: number[] = [];
    
    for (let i = 0; i < bytes.length - 1; i++) {
      if (bytes[i] === 7 || bytes[i] === 8) { // JMP or CALL
        locations.push(i);
      }
    }
    
    return locations;
  }

  /**
   * Find calls
   */
  private findCalls(bytes: number[]): number[] {
    const locations: number[] = [];
    
    for (let i = 0; i < bytes.length - 2; i++) {
      if (bytes[i] === 8) { // CALL
        locations.push(i);
      }
    }
    
    return locations;
  }

  /**
   * Attempt decryption with candidate keys
   */
  attemptDecryption(bytes: number[], candidates: number[]): BytecodeInfo[] {
    const results: BytecodeInfo[] = [];
    
    candidates.forEach(key => {
      const decrypted = bytes.map(b => b ^ key);
      const entropy = this.calculateEntropy(decrypted);
      
      // Lower entropy might indicate successful decryption
      if (entropy < 6.0) {
        results.push({
          raw: bytes,
          decrypted,
          encrypted: true,
          encryptionType: 'xor',
          key: [key],
          location: 'decrypted',
          size: decrypted.length,
          entropy,
          patterns: this.analyzePatterns(decrypted)
        });
      }
    });
    
    return results;
  }
}
